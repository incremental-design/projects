# This flake was initially generated by fh, the CLI for FlakeHub (version 0.1.25)
#
# This flake sets up development environments for golang, typescript, nix, and kubernetes
# It also creates a `lint`, `lintChanged`, `build`, `buildChanged`, `runTest`, `runTestChanged`, `publishDryRun` and `publishDryRunChanged` command, and links them into your $PATH
#
# See: https://zero-to-nix.com/concepts/flakes/
#
# A flake can have many sections. Different nix commands read
# different sections
#
# Core Nix built-ins:
# • apps - nix run
# • packages - nix build, nix shell
# • legacyPackages - nix build, nix shell
# • checks - nix flake check
# • devShells - nix develop
# • formatter - nix fmt
# • templates - nix flake init, nix flake new
# • overlays - Used by other flakes/nixpkgs
#
# Extended types - no direct nix commands, used by other tools:
# • hydraJobs - Hydra CI system
# • dockerImages - Docker build tools
#
# NixOS - used by nixos-rebuild, not nix CLI:
# • nixosConfigurations - nixos-rebuild
# • nixosModules - Imported by other flakes
#
# Home Manager - used by home-manager CLI:
# • homeConfigurations - home-manager switch
# • homeModules - Imported by other flakes
#
# nix-darwin - used by darwin-rebuild CLI:
# • darwinConfigurations - darwin-rebuild switch
# • darwinModules - Imported by other flakes
# ```
#
# See: https://github.com/DeterminateSystems/flake-schemas/blob/main/flake.nix
#
{
  description = "Development tools for Projects Monorepo";

  # Flake inputs
  inputs = {
    flake-schemas.url = "https://flakehub.com/f/DeterminateSystems/flake-schemas/*";

    nixpkgs.url = "https://flakehub.com/f/NixOS/nixpkgs/0.1.*";
  };

  # Flake outputs that other flakes can use
  outputs = {
    flake-schemas,
    nixpkgs,
    ...
  }: let
    # Helpers for producing system-specific outputs
    supportedSystems = ["x86_64-linux" "aarch64-darwin" "x86_64-darwin" "aarch64-linux"];
    forEachSupportedSystem = f:
      nixpkgs.lib.genAttrs supportedSystems (system:
        f {
          pkgs = import nixpkgs {inherit system;};
        });
  in {
    # Schemas tell Nix about the structure of your flake's outputs
    schemas = flake-schemas.schemas;

    # Development environments
    devShells = forEachSupportedSystem (
      {pkgs}: let
        languageDevShells = import ./.config/devShell.nix {inherit pkgs;};
      in
        languageDevShells
    );
  };
}
# New to nix? Confused by the syntax of this flake?
# No problem! The following should answer most of
# your questions:
#
#             ___     ____     __________    ___     ____
#            /   \   /   /    /__   ____/   \   \   /   /
#           /     \ /   /       /  /         \   \/   /
#          /       \   /       /  /          \      /
#         /   /\      /       /  /          /      \
#        /   /  \    /    ___/  /____     /   / \   \
#       /___/    \__/    /__________/   /___/    \___\
#
#        .-------_   ,--------,  ,--,    ,--,     .------.
#       /  ,---,  : /__   ___/  /  /    /  /     /   _   /
#      /  /    /  /   /  /     /  /    /  /      \   \'-'
#     /  /___-'  /   /  /     /  /    /  /        \   \
#    /   ,___,-''   /  /     /  /    /  /     .--. \   \
#   /   /       ___/  /___  /  /___ /  /____ /   '_'   /
#  /___/       /_________/ /______/ _______/ \_______.'
#
#
#  This is an abridged and opinionated version of
# (https://nixos.org/guides/nix-pills/)
#
# Nix constructs isolated, reproducible development environments.
# It is like a devcontainer, without the underlying linux.
#
#     ┌─────────────────────┐           ┌─────────────────────┐
#     │                     │           │                     │
#     │   Bring Your Own    │           │   Reproducible      │
#     │     Platform        │           │   Development       │
#     │                     │           │   Environment       │
#     │   ┌─────────────────┼───────────┼─────────────────┐   │
#     │   │                 │           │                 │   │
#     │   │                 │    Nix    │                 │   │
#     │   │                 │           │                 │   │
#     │   └─────────────────┼───────────┼─────────────────┘   │
#     │                     │           │                     │
#     │                     │           │                     │
#     └─────────────────────┘           └─────────────────────┘
#
# Nix brings reproducibility to the platform you already have
# (e.g. aarch64 darwin) instead of forcing you to replace your
# platform with a linux VM. Nix makes it possible to build for
# your platform, or even cross compile for any other platform.
#
# Without nix, matching dependencies across systems becomes
# every developer's problem:
#
#                    "It works on my machine!"
# ┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
# │   Developer A   │    │   Developer B   │    │   CI Server     │
# │                 │    │                 │    │                 │
# │ gcc 11.2        │    │ gcc 12.1        │    │ gcc 10.3        │
# │ node 18.5       │    │ node 16.8       │    │ node 14.2       │
# │ python 3.9      │    │ python 3.11     │    │ python 3.8      │
# │                 │    │                 │    │                 │
# └─────────────────┘    └─────────────────┘    └─────────────────┘
#   ✅ Builds fine         ❌ Build fails         ⚠️  Tests fail
#
# You tell nix what dependencies you need, and you give nix
# your build scripts. Nix creates a custom environment with
# those exact tools and then runs your scripts:
#
#                "Same dependencies = same results!"
# ┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
# │   Developer A   │    │   Developer B   │    │   CI Server     │
# │                 │    │                 │    │                 │
# │ gcc 11.2        │    │ gcc 11.2        │    │ gcc 11.2        │
# │ node 18.5       │    │ node 18.5       │    │ node 18.5       │
# │ python 3.9      │    │ python 3.9      │    │ python 3.9      │
# │                 │    │                 │    │                 │
# └─────────────────┘    └─────────────────┘    └─────────────────┘
#   ✅ Builds fine         ✅ Builds fine         ✅ Tests pass
#
# HOW IT WORKS:
#
# Nix is a package manager, like apt, homebrew or yum.Like
# most packages managers, it downloads packages from its online
# package repository http://www.nixpkgs.io. Unlike most package
# managers, it actually handles conflicting dependencies.
#
# Most package managers create ONE environment with ALL of the
# packages you install. If two packages conflict, you have to
# choose one or the other! Want to use a version of libMysql or
# openssl that isn't compatible with the other libraries in your
# OS? Good luck downloading and compiling the source yourself.
#
# If you have ever had to coax an ubuntu devcontainer into
# installing an out-of-release version of a library, you know
# how difficult this is.
#
# Traditional Package Managers - ONE shared environment:
# ┌─────────────────────────────────────────────────────────────────┐
# │                    System Environment                           │
# │                                                                 │
# │  gcc-11.2  nodejs-18  python-3.9  libssl-1.1  libmysql-8.0      │
# └─────────────────────────────────────────────────────────────────┘
#    ❌ Project A needs libssl-3.0 → CONFLICT!
#    ❌ Project B needs python-3.11 → CONFLICT!
#    ❌ Project C needs gcc-12 → CONFLICT!
#
# Nix sidesteps this problem entirely, by creating entirely
# separate environments for every project. Everything is in-release
# because each environment IS its own release! You can install as
# many versions of a library as you want, because nix automatically
# isolates packages between environments.
#
# ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐
# │   Project A     │  │   Project B     │  │   Project C     │
# │                 │  │                 │  │                 │
# │ gcc-11.2        │  │ gcc-11.2        │  │ gcc-12          │
# │ nodejs-18       │  │ nodejs-18       │  │ nodejs-18       │
# │ python-3.9      │  │ python-3.11     │  │ python-3.9      │
# │ libssl-1.1      │  │ libssl-1.1      │  │ libssl-3.0      │
# │ libmysql-8.0    │  │ libmysql-8.0    │  │ libmysql-8.0    │
# │                 │  │                 │  │                 │
# └─────────────────┘  └─────────────────┘  └─────────────────┘
#
#  ✅ No conflicts     ✅ No conflicts     ✅ No conflicts
#
#
#
# HOW TO USE NIX:
#
# To give nix your build scripts and dependencies, create a
# flake.nix, just like this one. A flake is a configuration file
# that constructs isolated environments for building projects.
#
# To define an isolated environment, create a `package` inside
# a nix flake.
#
# ```nix
# {
#   inputs.flake-schemas.url = "https://flakehub.com/f/DeterminateSystems/flake-schemas/*";
#
#   outputs = { flake-schemas, nixpkgs }:
#   let
#     supportedSystems = [ "x86_64-linux" "aarch64-linux" "x86_64-darwin" "aarch64-darwin" ];
#     forEachSupportedSystem = f: nixpkgs.lib.genAttrs supportedSystems (system: f {
#       pkgs = import nixpkgs { inherit system; };
#     });
#   in {
#     schemas = flake-schemas.schemas;
#
#     # Core Nix built-ins
#     packages = forEachSupportedSystem ({ pkgs }: { ... });
#                                                    ^^^
#                                                    build scripts go here
#   };
# }
# ```
#
# In this example, nix creates "default" package. This package
# constructs an environment that includes nodeJS 22 and npm.
# Then, it runs `npm run build`. To run this script, `nix build .#<name-of-script>`
#
# ```nix
# {
#   outputs = { flake-schemas, nixpkgs }:
#   let
#     supportedSystems = [ "x86_64-linux" "aarch64-linux" "x86_64-darwin" "aarch64-darwin" ];
#     forEachSupportedSystem = f: nixpkgs.lib.genAttrs supportedSystems (system: f {
#       pkgs = import nixpkgs { inherit system; };
#     });
#   in {
#     schemas = flake-schemas.schemas;
#
#     packages = forEachSupportedSystem ({ pkgs }: {
#       # Example: A Node.js project that runs 'npm build'
#       default = pkgs.stdenv.mkDerivation {
#         pname = "my-node-app";
#         version = "1.0.0";
#
#         src = ./.;
#
#         buildInputs = [ pkgs.nodejs_22 ];
#
#         buildPhase = ''
#           npm install
#           npm run build
#         '';
#
#         installPhase = ''
#           mkdir -p $out
#           cp -r dist/* $out/
#         '';
#       };
#     });
#   };
# }
# ```
# .---------------------,    .-------------.
# | nix build .#default ----->  nodejs 22  |
# '---------------------'    |  npm        |      .---------------.
#                            |             -------> npm run build |
#                            '-------------'      '---------------'
#
# Use the pkgs.stdenv.mkDerivation utility to specify the
# build tools and build scripts for your project:
#
# ```nix
# my-package = pkgs.stdenv.mkDerivation {
#   # Package metadata
#   pname = "my-package-name";
#   version = "1.0.0";
#   src = ./.;  # Source code location
#
#   # Build tools go in buildInputs
#   buildInputs = [ pkgs.nodejs_22 pkgs.cmake pkgs.python311 ];
#                   ^^^^^^^^^^^^ ^^^^^^^^^^^^ ^^^^^^^^^^^^^^
#                   Add any tools your build needs
#
#   # Build commands go in buildPhase
#   buildPhase = ''
#     npm install
#     npm run build
#     # ^^^^^^^^^^^
#     # Any shell commands you need
#   '';
#
#   # Installation commands go in installPhase
#   installPhase = ''
#     mkdir -p $out          # $out is the output directory
#     cp -r dist/* $out/     # Copy your built files here
#   '';
# };
# ```
#
# That's it! Three simple parts:
# 1. buildInputs = [ tools you need ]
# 2. buildPhase = '' commands to build ''
# 3. installPhase = '' copy results to $out ''
#
# Nix build creates a result/ folder in the Current
# working directory, and places the built artifacts
# inside it:
#
# Current Working Directory
# |
# |-- flake.nix
# '-- result   <- symlink to built output in nix store
#
#
# pkgs.stdenv.mkDerivation is the fundamental building
# block of Nix. It creates isolated environments where your
# builds run safely.
#
# ORCHESTRATING BUILD SCRIPTS WITH NIX:
#
# Nix doesn't replace your existing build tools. It orchestrates them.
#
# Nix can even compose several build scripts together. This is
# the most powerful feature of Nix.
#
# In this example a JS project composes a go project,
# which composes a c project.
#
#
# ```nix
# packages = forEachSupportedSystem ({ pkgs }: {
#   # Step 1: Build a C library with cmake
#   example-c-project = pkgs.stdenv.mkDerivation {
#     pname = "example-c-lib";
#     version = "1.0.0";
#     src = ./c-src;
#
#     buildInputs = [ pkgs.cmake ];
#
#     buildPhase = ''
#       cmake .
#       make
#     '';
#
#     installPhase = ''
#       mkdir -p $out/lib $out/include
#       cp libexample.so $out/lib/
#       cp example.h $out/include/
#     '';
#   };
#
#   # Step 2: Build Go binary that uses the C library
#   example-go-project = pkgs.stdenv.mkDerivation {
#     pname = "example-go-app";
#     version = "1.0.0";
#     src = ./go-src;
#
#     buildInputs = [ pkgs.go ];
#     # Include the C library as a dependency
#     propagatedBuildInputs = [ packages.example-c-project ];
#
#     buildPhase = ''
#       export CGO_CFLAGS="-I${packages.example-c-project}/include"
#       export CGO_LDFLAGS="-L${packages.example-c-project}/lib -lexample"
#       go build -o myapp main.go
#     '';
#
#     installPhase = ''
#       mkdir -p $out/bin
#       cp myapp $out/bin/
#     '';
#   };
#
#   # Step 3: JS project that copies Go binary as an asset
#   example-js-project = pkgs.stdenv.mkDerivation {
#     pname = "example-js-app";
#     version = "1.0.0";
#     src = ./js-src;
#
#     buildInputs = [ pkgs.nodejs_22 ];
#     # Include the Go binary as a dependency
#     propagatedBuildInputs = [ packages.example-go-project ];
#
#     buildPhase = ''
#       # Copy Go binary into assets
#       mkdir -p assets
#       cp ${packages.example-go-project}/bin/myapp assets/
#
#       npm install
#       npm run build
#     '';
#
#     installPhase = ''
#       mkdir -p $out
#       cp -r dist/* $out/
#       # Go binary is now bundled in the JS app
#     '';
#   };
# });
# ```
#
# Build dependency DAG when you run: nix build .#example-js-project
#
# .--------------------------.
# | nix build .#example-js   |  ← User command
# '--------------------------'
#                   |
#                   v
# .--------------------------.    .--------------------.
# | JS Environment           |    | example-go-project |  ← Dependency
# | nodejs_22 + npm          |<---| (binary artifact)  |
# | assets/myapp copied      |    '--------------------'
# |           |              |              |
# |           v              |              v
# |    .-------------.       |    .--------------------------.
# |    | npm install |       |    | nix build .#example-go   |  ← Recursive build
# |    | npm run build       |    '--------------------------'
# |    '-------------'       |              |
# '--------------------------'              v
#                                 .--------------------.    .--------------------.
#                                 | Go Environment     |    | example-c-project  |  ← Dependency
#                                 | go + cgo flags     |<---| (lib + headers)    |
#                                 | CGO_CFLAGS set     |    '--------------------'
#                                 |         |          |              |
#                                 |         v          |              v
#                                 |   .-------------.  |    .--------------------------.
#                                 |   | go build    |  |    | nix build .#example-c    |  ← Recursive build
#                                 |   '-------------'  |    '--------------------------'
#                                 '--------------------'              |
#                                                                     v
#                                                            .-------------------.
#                                                            |  C Environment    |
#                                                            |  cmake            |
#                                                            |        |          |
#                                                            |        v          |
#                                                            |  .-------------.  |
#                                                            |  | cmake .     |  |
#                                                            |  | make        |  |
#                                                            |  '-------------'  |
#                                                            '-------------------'
#
# Each build step runs in isolation, and references the outputs
# of its dependencies.
#
# If you want to build the Go and C project, without
# building the JS project `nix build .#example-go-project`
#
# If you want to build the C project, without building
# the Go and JS project, you can `nix build .#example-c-project`
#
# DEBUGGING NIX BUILD
#
# use `nix build --log-format raw .#name-of-pkg` to print
# build progress and errors
#
# use `nix build --rebuild .#name-of-pkg` to delete the cached
# build artifact and rebuild from scratch
#
#
# LOADING BUILD TOOLS INTO YOUR SHELL WITH NIX:
#
# Many flakes also contain devShells. DevShells install
# dependencies in your $PATH. They make it possible
# to run arbitrary commands, with the same build tools
# you use in your build scripts.
#
# ```nix
# {
#   inputs.nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
#
#   outputs = { nixpkgs }:
#   let
#     supportedSystems = [ "x86_64-linux" "aarch64-linux" "x86_64-darwin" "aarch64-darwin" ];
#     forEachSupportedSystem = f: nixpkgs.lib.genAttrs supportedSystems (system: f {
#       pkgs = import nixpkgs { inherit system; };
#     });
#   in {
#     devShells = forEachSupportedSystem ({ pkgs }: {
#       default = pkgs.mkShell {
#         buildInputs = [ pkgs.nodejs_22 ];
#       };
#     });
#   };
# }
# ```
# In this example, nix creates a shell with nodeJS 22
# If your $PATH contains a different version of node,
# nix will temporarily shadow it with nodeJS 22. You
# can use this version of node, without installing it
# globally and managing it with node version manager.
#
# $PATH = /nix/store/abc123-nodejs-22/bin:/usr/local/bin:/usr/bin
#          ↑                          ↑               ↑
#          │                          │               │
#      nix nodejs 22              local node     system node
#      (takes priority)           (shadowed)     (shadowed)
#
#
#
#
#
# MAKING CROSS-PLATFORM DEVELOPMENT ENVIRONMENTS, WITH NIX
#
# Nix flakes work across platforms. the `nixpkgs.lib.genAttrs`
# utility splits a flake into platform-specific variants.
# Each variant downloads the build of the dependencies
# for its respective operating system and processor
# architecture.
#
# ```nix
# {
#   inputs.nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
#
#   outputs = { nixpkgs }:
#   let
#     supportedSystems = [ "x86_64-linux" "aarch64-linux" "x86_64-darwin" "aarch64-darwin" ];
#     forEachSupportedSystem = f: nixpkgs.lib.genAttrs supportedSystems (system: f {
#       pkgs = import nixpkgs { inherit system; };
#    #  ^^^
#    #  use builds of packages that are specific to a given system
#     });
#   in {
# }
# ```
#
# ┌─────────────────────┐                       ┌─────────────────────┐
# │ Systems List        │                       │ Platform-Specific   │
# │                     │                       │ Packages            │
# │ ["x86_64-linux"     │  ┌─────────────────┐  │                     │
# │  "aarch64-linux"    │──▶ nixpkgs.lib.    ──▶│ x86_64-linux-pkgs   │
# │  "x86_64-darwin"    │  │ genAttrs        │  │ aarch64-linux-pkgs  │
# │  "aarch64-darwin"]  │  │                 │  │ x86_64-darwin-pkgs  │
# │                     │  └─────────────────┘  │ aarch64-darwin-pkgs │
# └─────────────────────┘                       └─────────────────────┘
#
# While this technically creates multiple, slightly different
# environments - depending on the machine's underlying os and
# architecture - all machines of the same OS and arch will
# build using the exact same environment.
#
# the forEachSupportedSystem expression runs
# nixpkgs.lib.genAttrs. If your build scripts are
# platform-specific, you can use it to customize
# them for each platform and architecture.
#
# This example sets different environment variables
# based on the platform:
#
# - BUILD_TARGET: "linux" or "darwin"
# - BUILD_ARCH: "arm64" or "x64"
#
# ```nix
# {
#   inputs.nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
#
#   outputs = { nixpkgs }:
#   let
#     supportedSystems = [ "x86_64-linux" "aarch64-linux" "x86_64-darwin" "aarch64-darwin" ];
#     forEachSupportedSystem = f: nixpkgs.lib.genAttrs supportedSystems (system: f {
#       pkgs = import nixpkgs { inherit system; };
#     });
#   in {
#     packages = forEachSupportedSystem ({ pkgs }: {
#       default = pkgs.stdenv.mkDerivation {
#         pname = "platform-aware-app";
#         version = "1.0.0";
#
#         src = ./.;
#
#         buildInputs = [ pkgs.nodejs_22 ];
#
#         buildPhase = ''
#           export BUILD_TARGET=${if pkgs.stdenv.isLinux then "linux" else "darwin"}
#           export BUILD_ARCH=${if pkgs.stdenv.isAarch64 then "arm64" else "x64"}
#           export NODE_ENV=production
#
#           echo "Building for $BUILD_TARGET-$BUILD_ARCH"
#           npm install
#           npm run build
#         '';
#
#         installPhase = ''
#           mkdir -p $out
#           cp -r dist/* $out/
#         '';
#       };
#     });
#   };
# }
# ```
#
# the forEachSupportedSystem function lets you moves messy
# platform-detection logic out of your build scripts and
# into the nix flake.
#
#     WITHOUT forEachSupportedSystem:
#     ┌─────────────────────────────┐
#     │      Build Script           │
#     │                             │
#     │ if os.platform() == "linux":│
#     │   TARGET = "linux"          │
#     │ elif os.platform() =="win32"│
#     │   TARGET = "windows"        │
#     │ elif os.platform()=="darwin"│
#     │   TARGET = "macos"          │
#     │                             │
#     │ if arch == "arm64":         │
#     │   ARCH = "arm64"            │
#     │ else:                       │
#     │   ARCH = "x64"              │
#     │                             │
#     │ npm run build               │
#     └─────────────────────────────┘
#
#     WITH forEachSupportedSystem:
#     ┌─────────────────────────────┐    ┌─────────────────────────────┐
#     │         Nix Flake           │    │      Build Script           │
#     │                             │    │                             │
#     │ BUILD_TARGET = if isLinux   ────▶│ # Clean, simple:            │
#     │   then "linux"              │    │ npm run build               │
#     │   else "darwin"             │    │                             │
#     │                             │    │ # Uses $BUILD_TARGET and    │
#     │ BUILD_ARCH = if isAarch64   │    │ # $BUILD_ARCH from nix      │
#     │   then "arm64"              │    │                             │
#     │   else "x64"                │    │                             │
#     └─────────────────────────────┘    └─────────────────────────────┘
#       Platform logic lives here           Platform logic removed!
#
#
#
#
# WRITING YOUR OWN UTILITY FUNCTIONS, WITH NIX
#
# Nix flakes are far more powerful than package.json
# pyproject.toml or make files, because nix is a
# turing-complete, purely functional scripting language:
#
# in fact, lib.system.genAttrs and pkgs.stdenv.mkDerivation
# are both scripts, written in nix!
#
#  script                   | source
# --------------------------|------------------
#  pkgs.stdenv.mkDerivation | https://github.com/NixOS/nixpkgs/blob/master/pkgs/stdenv/generic/make-derivation.nix
# lib.system.genAttrs       | https://github.com/NixOS/nixpkgs/blob/master/lib/system.nix
#
# Nix scripts compose these utilities into larger
# scripts that build everything from binaries
# to operating system images.
#
# to make a nix script, create a file that ends
# in .nix, and then write exactly one expression.
# An expression is anything that can be assigned
# to a variable.
#
#   good.nix              bad.nix
#    ________________      ________________
#   /                |    /                |
#   | 42             |    | 42             |
#   |                |    | 42             |
#   |                |    | 42             |
#   |                |    |                |
#   |                |    |                |
#   |                |    |                |
#   |________________|    |________________|
#   nix eval good.nix     A .nix file cannot
#   returns 42            contain more than
#                         one expression.
#                         This contains 3.
#
#   good.nix              bad.nix
#    ________________      ________________
#   /                |    /                |
#   | {              |    | x = x + y      |
#   |   x = x: x + y;|    | y = 42         |
#   |   y = 42;      |    |                |
#   | }              |    |                |
#   |                |    |                |
#   |                |    |                |
#   |________________|    |________________|
#   nix eval good.nix     A .nix file cannot
#   returns               contain more than
#   {                     one expression.
#     x = x: x + y;       This contains 2.
#     y = 42;
#   }
#
#
# If you need to declare multiple variables for an
# expression, wrap them in a "let...in" clause
#
#   good.nix              bad.nix
#    ________________      ________________
#   /                |    /                |
#   | let            |    | x = 42;        |
#   |   x = 42;      |    | y = 10;        |
#   |   y = 10;      |    | x + y          |
#   | in             |    |                |
#   |   x + y        |    |                |
#   |                |    |                |
#   |________________|    |________________|
#   evaluates to 42       contain more than
#
#
# if you need to pass one or more variables into
# an expression, return a function
#
#
# nix variables can be of the following types
#
# type               example
#
# integer            x = 3
#
# floating point     w = 3.14
# number             x = 2.5 * 2        <- a float * an int will
#                                          always be a float, even
#                                          if it is equal to an int.
#                                          This is because nix
#                                          preserves floating point
#                                          precision
#                    y = 3 + 2.5        <- an integer + a float is a
#                                          float
#                    z = 3/ 2           <- an integer that does not
#               -----------^----------      divide evenly is a float
#               You have to leave a
#               space after / for nix
#               to recognize it as a
#               division operator
#
# boolean            u = false
#                    v = true
#                    w = 1 < 2                  <- evaluates to true
#                    x = 3 > 4                  <- evaluates to false
#                    y = "foo" == "foo"         <- evaluates to true
#                    x = "foo" != "bar"         <- evaluates to true
#                    z = true && false          <- evaluates to false
#                    a = true || false          <- evaluates to true
#                    b = true && false || true  <- evaluates to true
#
# string             y = "foo"
#                    z = "Hello ${42}"   # evaluates to "Hello 42"
#
# path               z = path/to/file   <- nix recognizes path
#                                          as a primitive type
#                                          to make locating
#                                          files in the nix
#                                          store easier
#
# list               x = [ "foo" 3 3.14 ]
#                     ----------^---------
#                     items in a list are
#                     separated by a space
#
#                    y = [
#                      1
#                      2
#                      [ 3 4 5 ]        <- lists can contain
#                    ]                     other lists
#
#                    z = [
#                      "hello"
#                      {                <- lists can contain
#                        a = 1;            attribute sets
#                        b = 2;            (a.k.a maps)
#                      }
#                      42
#                    ]
#
#
# attribute set      z = { a = 1; b = 2; }
# (a.k.a map)         ----------^---------
#                     items in a map are
#                     followed by a semi-
#                     colon
#
#                    x = {
#                      a = 1;
#                      b = [ 1 2 3 ];   <- attribute sets can
#                      c = "hello";        contain members
#                    }                     that are lists
#
#                    y = {
#                      a = 1;
#                      b = {            <- attribute sets can
#                        x = 10;           contain members
#                        y = 20;           that are attribute
#                      };                  sets
#                      c = "world";
#                    }
#
# function           f = x: x + 1               <- takes x as input and
#                                                  returns x + 1
#                    g = x: y: x + y            <- takes x as input and returns
#                                                  a function that takes y as
#                                                  input, where x is already
#                                                  set in the returned function.
#                                                  in functional programming,
#                                                  this is known as "currying"
#                    h = { a, b, ... }: a + b   <- takes an attribute set as
#                       ----------^----------      an input and destructures it
#                       you must use ... to
#                       extract a and b from
#                       the attribute set. If
#                       you omit it, then nix
#                       will error if the
#                       attribute set has any
#                       members other than a
#                       and b
#
#
# to make a nix script, create a file that ends in .nix, and then write exactly one expression.
# An expression is anything that can be assigned to a variable.
#
#   good.nix              bad.nix
#    ____________________      ____________________
#   /                    |    /                    |
#   | let                |    | let                |
#   |   fx = x: y: x * y |    |   fx = x y: x * y  |
#   | in                 |    | in                 |
#   |  fx 3 2            |    | fx 3 2             |
#   |_-_-_-_-_-_-_-_-_-_-|    |_-_-_-_-_-_-_-_-_-_-|
#    evaluates to 6           A function can only
#                             accept one argument
#                             per invocation.
#
# currying takes the first argument, and returns a
# function that takes the second argument
#
#   fx 3 2
#  -^----------------
#   3 -> x: y: x * y      1. fx receives 3, and returns
#        3: y: 3 * y         an anonymous function
#
#   2 ->    y: 3 * y      2. the anonymous function
#           2: 3 * 2         receives 2 and returns
#                  6         the answer
#
# if you don't want to curry a function that takes multiple
# arguments, you can pass them all at once in a single
# attribute set:
#
#   let
#     f = { x, y, z }: x + y + z;
#   in
#     f { x = 1; y = 2; z = 3; }  <- evaluates to 6
#   ----^------------------------
#   all arguments are passed at
#   once in a single attribute
#   set
#
#
# use () to immediately evaluate an expression
# instead of assigning it to a variable:
#
#   foo.nix
#    _________________________
#   /                         |
#   | y = [                   |
#   |   (import bar.nix 1) <------ bar.nix
#   |   (import bar.nix 2)    |     ____________
#   |   (import bar.nix 3)    |    /            |
#   | ];                      |    | x: x * 2   |
#   |_-_-_-_-_-_-_-_-_-_-_-_-_|    |_-_-_-_-_-_-|
#   y evaluates to [ 2 4 6 ]
#
#   the parentheses cause each import
#   to be evaluated immediately with
#   its argument
#
#
# compose nix scripts, with the import keyword
# to import a nix script into another, use the import keyword:
#
#   foo.nix
#    ______________________
#   /                      |
#   | y = import bar.nix <-|--- bar.nix
#   |                      |     ____________
#   |                      |    /            |
#   |                      |    | 42         |
#   |                      |    |_-_-_-_-_-_-|
#   |_-_-_-_-_-_-_-_-_-_-_-|
#   evaluates to y = 42
#
#
# use a function by passing arguments into it
# let
#   f = x y z: x + y + z;
# in
#   f 1 2 3                 <- evaluates to 6
# ---^--------------------
# arguments are separated
# by spaces and passed in
# following the name of
# the function
#
#
# pass variables into a nix script, by returning
# a function that uses the variables
#
#   foo.nix
#    _________________________
#   /                         |
#   | y = import bar.nix { <------ bar.nix
#   |   a = 1;                |     _________________
#   |   b = 2;                |    /                 |
#   | }                       |    | { a, b }: a + b |
#   |                         |    |_-_-_-_-_-_-_-_-_|
#   |_-_-_-_-_-_-_-_-_-_-_-_-_|
#   evaluates to y = 3
#
#
# nix has several builtins for iterating through lists
# and attrsets (attribute sets, also known as maps)
#
# https://nix.dev/manual/nix/2.28/language/builtins.html
#
# LISTS:
# Lists are ordered collections of values, written with square brackets
# and space-separated items:
#   myList = [ "a" "b" "c" 1 2 3 ]
#   mixedList = [ { name = "Alice"; } [ 1 2 ] "hello" ]
#
# here's how Nix lists are similar to lists in other languages:
#
#     Python list:
#    _______________
#   /               |
#   | my_list = [   |
#   |   "a",        |
#   |   "b",        |
#   |   1,          |
#   |   2           |
#   | ]             |
#   |_______________|
#
#     JavaScript list:
#    _______________
#   /               |
#   | const myList = [
#   |   "a",        |
#   |   "b",        |
#   |   1,          |
#   |   2           |
#   | ];            |
#   |_______________|
#
#    Go list:
#    _______________
#   /               |
#   | myList := []interface{}{
#   |   "a",        |
#   |   "b",        |
#   |   1,          |
#   |   2,          |
#   | }             |
#   |_______________|
#
#    Nix list:
#    _______________
#   /               |
#   | myList = [    |
#   |   "a"         |
#   |   "b"         |
#   |   1           |
#   |   2           |
#   | ]             |
#   |_______________|
#
# Key differences in Nix:
# - No commas between elements (space-separated)
#     Nix list:
#    _______________
#   /               |
#   | myList = [    |
#   |   "a"         |
#   |   "b"         |  <- no commas here
#   |   1           |  <- or here
#   |   2           |  <- or here
#   | ]             |
#   |_______________|
#   ----^-----------
#   space-separated elements
#   instead of comma-separated
#
# - No quotes around variable names when referencing them
#     Variable reference:
#    _______________
#   /               |
#   | let           |
#   |   name = "Alice";
#   |   greeting = name;  <- no quotes around 'name'
#   | in            |
#   |   greeting    |
#   |_______________|
#   --------^-------
#   variable name used directly
#   (would be "name" in other languages)
#
# - Can contain any mix of types without declaration
#     Mixed types:
#    _______________
#   /               |
#   | mixed = [     |
#   |   "string"    |  <- string
#   |   42          |  <- integer
#   |   true        |  <- boolean
#   |   { a = 1; }  |  <- attrset
#   | ]             |
#   |_______________|
#   ----^-----------
#   no type declarations needed
#
# Nix also has attribute sets, which are knows as maps
# or objects in other languages.
#
# Attribute sets are key-value collections, written with curly braces
# and semicolon-separated key = value pairs:
#   myAttrs = { name = "John"; age = 30; active = true; }
#   nestedAttrs = {
#     user = { name = "Jane"; email = "jane@example.com"; };
#     settings = { theme = "dark"; lang = "en"; };
#   }
#
# Nix attrsets are similar to dictionaries, objects and maps
# in other languages
#
#     Python dict:
#    ______________
#   /              |
#   | my_dict = {  |
#   |   "name": "John",
#   |   "age": 30, |
#   |   "active": True
#   | }            |
#   |______________|
#
#     JavaScript object:
#    ______________
#   /              |
#   | const myObj = {
#   |   name: "John",
#   |   age: 30,
#   |   active: true
#   | };           |
#   |______________|
#
#     Go map:
#    ______________
#   /              |
#   | myMap := map[string]interface{}{
#   |   "name": "John",
#   |   "age": 30,
#   |   "active": true,
#   | }            |
#   |______________|
#
#     Nix attrset:
#    ______________
#   /              |
#   | myAttrs = {  |
#   |   name = "John";
#   |   age = 30;
#   |   active = true;
#   | }            |
#   |______________|
#
# Key differences in Nix:
# - Semicolons instead of commas between key-value pairs
#     Nix attrset:
#    _______________
#   /               |
#   | myAttrs = {   |
#   |   name = "John";  <- semicolon here
#   |   age = 30;      <- and here
#   |   active = true; <- and here
#   | }             |
#   |_______________|
#   --------^-------
#   semicolons separate pairs
#   (not commas like other languages)
#
# - Keys don't need quotes (unless they contain special characters)
#     Key syntax:
#    _______________
#   /               |
#   | attrs = {     |
#   |   name = "John";     <- no quotes around 'name'
#   |   "user-id" = 123;   <- quotes needed for hyphens
#   |   firstName = "Jane"; <- camelCase works
#   | }             |
#   |_______________|
#   ----^-----------
#   simple keys don't need quotes
#   (unlike JSON or some other formats)
#
# - Use = instead of : for key-value assignment
#     Assignment operator:
#    _______________
#   /               |
#   | myAttrs = {   |
#   |   name = "John";  <- equals sign
#   |   age = 30;      <- not colon
#   | }             |
#   |_______________|
#   -------^--------
#   equals for assignment
#   (colon is used elsewhere in Nix)
#
# - Access with dot notation: myAttrs.name or bracket notation: myAttrs."name"
#     Attribute access:
#    _______________
#   /               |
#   | let           |
#   |   attrs = { name = "Alice"; };
#   |   getName = attrs.name;        <- dot notation
#   |   getQuoted = attrs."name";    <- bracket notation
#   | in getName    |
#   |_______________|
#   ---------^------
#   both access methods work
#   (brackets needed for special chars)
#
#
# Nix provides several builtins for iterating over maps
# and lists.
#
# ESSENTIAL ITERATION FUNCTIONS:
# The three most important functions you need to know:
#
# 1. builtins.map - Transform each element in a list
#     Transform function:
#    ___________________
#   /                   |
#   | builtins.map      |
#   |   (x: x * 2) [    |
#   |   1               |
#   |   2               |
#   |   3               |
#   | ]                 |
#   |___________________|
#   --------^--------
#   returns [ 2 4 6 ]
#
#     String template function:
#    _______________________
#   /                       |
#   | builtins.map          |
#   |   (name: "Hello       |
#   |    ${name}") [        |
#   |   "Alice"             |
#   |   "Bob"               |
#   | ]                     |
#   |_______________________|
#   ----------^----------
#   returns [ "Hello Alice" "Hello Bob" ]
#
# 2. builtins.filter - Keep only elements that match a condition
#     Numeric filter:
#    __________________
#   /                  |
#   | builtins.filter  |
#   |   (x: x > 5) [   |
#   |   1              |
#   |   10             |
#   |   3              |
#   |   8              |
#   |   2              |
#   | ]                |
#   |__________________|
#   --------^--------
#   returns [ 10 8 ]
#
#     String filter:
#    ____________________
#   /                    |
#   | builtins.filter    |
#   |   (s: s != "") [   |
#   |   "a"              |
#   |   ""               |
#   |   "b"              |
#   |   ""               |
#   |   "c"              |
#   | ]                  |
#   |____________________|
#   ---------^---------
#   returns [ "a" "b" "c" ]
#
# 3. builtins.concatMap - Map then flatten (very common pattern)
#     Duplicate function:
#    ____________________
#   /                    |
#   | builtins.concatMap |
#   |   (x: [ x x ]) [   |
#   |   1                |
#   |   2                |
#   |   3                |
#   | ]                  |
#   |____________________|
#   ---------^---------
#   returns [ 1 1 2 2 3 3 ]
#
#     Template expansion:
#    ____________________
#   /                    |
#   | builtins.concatMap |
#   |   (name: [         |
#   |   "Mr. ${name}"    |
#   |   "Ms. ${name}"    |
#   | ]) [               |
#   |   "Smith"          |
#   |   "Jones"          |
#   | ]                  |
#   |____________________|
#   ---------^---------
#   returns [ "Mr. Smith" "Ms. Smith" "Mr. Jones" "Ms. Jones" ]
#
# Cross-language equivalents:
#
# | Language   | Map              | Filter           | Concat Map           |
# |------------|------------------|------------------|----------------------|
# | JavaScript | Array.map()      | Array.filter()   | Array.flatMap()      |
# | Python     | map() / [...]    | filter() / [...] | itertools.chain()    |
# | Nix        | builtins.map     | builtins.filter  | builtins.concatMap   |
#
# All iteration functions available in Nix:
#
# Lists:
# • builtins.map - Transform each element
# • builtins.filter - Keep elements matching condition
# • builtins.foldl' - Reduce list from left (recommended)
# • builtins.foldr - Reduce list from right
# • builtins.length - Get list length
# • builtins.elemAt - Get element at index
# • builtins.head - Get first element
# • builtins.tail - Get all elements except first
# • builtins.sort - Sort list with comparison function
# • builtins.groupBy - Group elements by key function
# • builtins.partition - Split list into two based on predicate
#
# Attribute Sets (objects/maps):
# • builtins.mapAttrs - Transform each value
# • builtins.filterAttrs - Keep key-value pairs matching condition
# • builtins.attrNames - Get all keys as list
# • builtins.attrValues - Get all values as list
# • builtins.hasAttr - Check if key exists
# • builtins.getAttr - Get value by key
# • builtins.removeAttrs - Remove specified keys
# • builtins.intersectAttrs - Keep only common keys
#
# Conversion:
# • builtins.listToAttrs - Convert list to attribute set
# • builtins.zipAttrsWith - Merge multiple attribute sets
#
# Documentation: https://nixos.org/manual/nix/stable/language/builtins.html
#
#
# WRITING FILES AND BUILD SCRIPTS WITH NIX:
#
# Most nix scripts write files, or shell scripts that can be
# executed later on:
#
# Writing JSON configuration files:
# ```nix
# config-file = pkgs.writeText "config.json" (builtins.toJSON {
#   database = { host = "localhost"; port = 5432; };
#   features = [ "auth" "logging" "metrics" ];
# });
# ```
#
# Writing YAML configuration files:
# ```nix
# yamlFormat = pkgs.formats.yaml { };
# yaml-config = yamlFormat.generate "config.yaml" {
#   database = {
#     host = dbHost;
#     port = dbPort;
#   };
#   features = [ "auth" "logging" "metrics" ];
# };
# ```
#
# Writing shell scripts with string interpolation:
# ```nix
# my-script = pkgs.writeScript "deploy.sh" ''
#   #!/bin/bash
#
#   # Nix string interpolation with ${}
#   APP_NAME="${pname}"
#   VERSION="${version}"
#   BUILD_DIR="${placeholder "out"}"
#
#   echo "Deploying $APP_NAME version $VERSION"
#   echo "Build output: $BUILD_DIR"
#
#   # Multi-line strings preserve formatting
#   cat << EOF > deployment.yaml
#   apiVersion: apps/v1
#   kind: Deployment
#   metadata:
#     name: ${pname}
#   spec:
#     replicas: 3
#   EOF
# '';
# ```
#
# Writing files in build phases:
# ```nix
# my-package = pkgs.stdenv.mkDerivation {
#   # ...
#   buildPhase = ''
#     # Generate a config file during build
#     cat > config.ini << EOF
#     [database]
#     host=${dbHost}
#     port=${toString dbPort}
#
#     [app]
#     name=${pname}
#     debug=${if enableDebug then "true" else "false"}
#     EOF
#
#     # Build the application
#     make build
#   '';
#   installPhase = ''
#     mkdir -p $out/bin $out/etc
#     cp my-app $out/bin/
#     cp config.ini $out/etc/
#   '';
# };
# ```
#
# Key string features:
# • '' multiline strings preserve indentation and newlines
# • ${...} interpolates Nix expressions into strings
# • ${placeholder "out"} references build outputs safely
# • builtins.toJSON converts Nix data to JSON strings
# • pkgs.formats.yaml.generate converts Nix attribute sets to YAML
#

