name: Tag Main

# Tag Main Pipeline Flow:
#
# This workflow iterates through commits from
# merge base to HEAD. For each commit, it runs recurse
# which outputs tags that should be created, then
# creates and pushes them atomically.

on:
  push:
    branches: [main]

jobs:
  tag-main:
    runs-on: ubuntu-latest
    outputs:
      tags: ${{ steps.collect-tags.outputs.tags }}
    steps:
      - uses: DeterminateSystems/determinate-nix-action@v3
      - uses: DeterminateSystems/magic-nix-cache-action@main
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Install Nix
        uses: DeterminateSystems/nix-installer-action@v4
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate GitHub App Token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}

      - name: Build recurse.nix script
        run: |
          nix-build .config/recurse.nix --arg pkgs "import (builtins.getFlake \"path:$(pwd)\").inputs.nixpkgs {}" --arg steps '["project-lint-semver"]'

      - name: Collect and push tags
        id: collect-tags
        env:
          GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          set -e

          echo "============================================================"
          echo "üîç Processing commits from merge base to HEAD"
          echo "============================================================"

          MERGE_BASE=${{ github.event.before }}
          COMMITS=$(git rev-list --reverse $MERGE_BASE..HEAD)

          if [[ -z "$COMMITS" ]]; then
            echo "‚ÑπÔ∏è No commits to process"
            exit 0
          fi

          declare -a TAGS_TO_CREATE=()

          for commit in $COMMITS; do
            echo "============================================================"
            echo "üîç Processing commit: $commit"
            echo "üìù Message: $(git log -1 --pretty=%B $commit)"
            echo "============================================================"

            git checkout -q $commit

            echo "üèÉ Running recurse for commit $commit..."

            # recurse outputs tags (one per line)
            while IFS= read -r tag; do
              if [ -n "$tag" ]; then
                # Store both tag and commit sha in array (alternating: tag, sha, tag, sha, ...)
                TAGS_TO_CREATE+=("$tag" "$commit")
                echo "  üìå Collected tag: $tag for commit: $commit"
              fi
            done < <(./result/bin/recurse)

            echo "‚úÖ Commit $commit processed"
            echo ""
          done

          git checkout -q ${{ github.sha }}

          if [ -L result ]; then
            unlink result
          fi

          if [ ${#TAGS_TO_CREATE[@]} -gt 0 ]; then
            echo "============================================================"
            echo "üì§ Creating ${#TAGS_TO_CREATE[@]} tags via API..."
            echo "============================================================"

            # Iterate through pairs: tag at index i, sha at index i+1
            for ((i=0; i<${#TAGS_TO_CREATE[@]}; i+=2)); do
              tag="${TAGS_TO_CREATE[$i]}"
              sha="${TAGS_TO_CREATE[$((i+1))]}"

              echo "Creating tag: $tag for commit: $sha"

              if gh api repos/${{ github.repository }}/git/refs \
                -f ref="refs/tags/$tag" \
                -f sha="$sha" 2>&1; then
                echo "‚úÖ Created tag: $tag"
              else
                # Creation failed, check if tag already exists
                if gh api repos/${{ github.repository }}/git/refs/tags/$tag &>/dev/null; then
                  echo "  ‚ÑπÔ∏è  Tag already exists: $tag"
                else
                  echo "  ‚ùå Failed to create tag: $tag" >&2
                  exit 1
                fi
              fi
            done
          else
            echo "‚ÑπÔ∏è No tags to create"
          fi
