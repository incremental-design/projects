# Contribute to Projects:

> [!TIP] Before you contribute to any project in this monorepo, you must [install nix](https://determinate.systems/nix-installer/) and [nix-direnv](https://github.com/nix-community/nix-direnv). This monorepo uses nix and nix-direnv to automatically bootstrap all dev tools. Don't install the dev tools for these projects manually. Use the versions provided by nix.

<details>
<summary>Why a monorepo?</summary>
TL;DR life is short. I don't have time to leapfrog between different repos, and neither do you.

In many ways, programming is the pursuit of maximum efficiency. A skilled programmer doesn't just optimize the time complexity of the machine. They optimize the time complexity of their life. In this case, that means putting all the code we write in ONE place where we can all see it, debug it and reuse it. No messing with submodules, symlinks, or package proxies.

<details>

<details>
<summary>Why nix?</summary>
Nix is a _cross platform_, _deterministic_ build tool. With nix, if it works on your machine, it works on _all_ machines.

Nix makes reproducible builds possible. This is very important when working with platform-specific, compiled code. Without nix, build scripts, such as makefiles, link against whatever libraries they find on your development machine. These libraries change from one OS to the next, making it difficult to build the same software on different machines. Nix versions libraries, and provides them directly to build scripts.

```
         ;^'^i:r;,
 ,nIix.l'         p
n                  c
C       nixpkgs    D
`-._______,_____.-"
          |
       dev tools
          |
      ____V_____
    /           |
    | flake.nix |                ,-----.________
    |           |                |              |
    |           +---- copied ---->   /nix/store |
    |           |     into       |              |
    |___________|                '______,_______'
                                        |
                                        |
                                 _______V_______
                                |  nix-direnv   |
                                |_______,_______|
                                        |
                                        |
                                    symlinked
                                      into
        ,-------------------------------'
 _______V________
| $PATH          |
|                |
|                |
|________________|
```

Nix also makes makes reproducible development environments possible, without dev containers. Nix versions dev tools, such as npm, node, go, terraform, etc. in the same way that it versions libraries. Nix-direnv automatically loads these dev tools to your $PATH, when you `cd` into this repo. It unloads these tools when you `cd ..`. You don't have to globally any dev tools (other than nix itself), you don't have to install version managers and you don't have to remember to switch between versions of tools when you switch between projects.
</details>

## Develop

This monorepo is split into several projects. Each project contains its own dev tools.

To load the dev tools, `cd` into the project. `nix-direnv` will read the `.envrc` in the project, and add the devtools to your $PATH. Then, it will print a list of commands you can use to build, test, and publish the project. e.g.

```
   command       │ description
  ───────────────┼──────────────────────────────────────────────────────────
   build         │ build .nix files
   lint          │ lint .nix files
   lintSemVer    │ lint the semantic version of a .nix project
   publish       │ publish nix packages.
   publishDryRun │ dry-run publish nix packages.
   runTest       │ test .nix files - this is a no-op, since we haven't set
                 │ up any test framework for nix
```
All projects will contain a `build`, `lint`, `lintSemVer`, `publish`, `publishDryRun` and `runTest` command. Some projects may contain additional commands.

This repository automatically runs the `lint`, `lintSemVer`, `build` and `runTest` commands in every project, before you push commits to any remote, using the [pre-push hook](.config/installGitHooks.nix). It also runs these hooks in [github actions](.github/workflows/push.yml) every time you push to github.

### Repository Structure:

  ```
   projects/
     |                   -,
     |- .config/          |- configuration files included in flake.nix
     |                   -'
     |                   -,
     |- .github/          |- continuous integration configuration. Do not modify this.
     |                   -'
     |                   -,
     |- .vscode           |  configuration files for zed, vscode and cursor.
     |                    |- Do not modify these files. They are automatically
     |- .zed              |  generated by flake.nix
     |                   -'
     |                   -,
     |- .direnv           |  configuration and cache for nix-direnv. Do not modify
     |                    |- these.
     |- .envrc            |
     |                   -'
     |                   -,
     |- .gitignore        |- list of files to ignore
     |                   -'
     |                   -,
     |- flake.nix         |  installs dev environment when you `cd` into projects/
     |                    |- or open projects/ in zed editor. Auto-generates
     |- flake.lock        |  editor configuration folders.
     |                   -'
     |                   -,
     |- go-starter        |
     |                    |
     |- typescript-       |- example projects. Do not modify these.
     |  starter           |
     |                    |
     |                   -'
     |                   -,
     |- infrastructure    |- project that contains NixOS, NixOps, and Kubernetes code
     |                   -'  used to configure and deploy development hardware
     :
     :
  ```

  ### When to make a new project:

TL;DR: almost never.

A project is a commitment to maintain a piece of code, indefinitely. When you make a project, it must have a stable API with 100% test coverage of all methods.

This is a lot of extra work! Especially if no one else is using your project!

  ```
   projects/
     |
     |- project-a/
     |
     |
     |- project-b/
     |
     |
     |- your-new-project/
     |    |
     |    '- your-fancy-code   <-- STOP. Don't do this
     :
  ```
Instead of making a project, modify an existing project. Make sure you don't break its API.

  ```
   projects/
     |
     |- project-a/
     |    |
     |    '- your-fancy-code    <- it's better to DUPLICATE
     |                             the code between two packages
     |                             than it is to commit to maintaining
     |- project-b/                 a third package.
     |    |
     |    '- your-fancy-code
     |
     :
     :
  ```

If you _think_ you have a piece of code that can be shared between two existing projects, you probably don't. Just duplicate it in each existing project. In most cases, the piece of code will end up diverging over time, because the code will likely fulfill a different use case in each project.

If the code does _not_ diverge over time, it hasn't changed in at least 4 months, and other human beings want to use it, then it's a good candidate to refactor into its own project.

I will only merge a PR with a project if
1. It contains 100% unit test coverage of all public APIs
2. Exposes some kind of documentation (e.g. if it is an API server, it must have an API.json). If it is a library, it must have auto-generated documentation.
3. It is referenced by at least THREE other projects. Ideally, one of the three projects should be in a repository other than this monorepo.
4. Contains a README and a CONTRIBUTE that follow the style guide prescribed by [stubProject.nix](./.config/stubProject.nix)
5. Has a public API that has been untouched in the past 4 months.

### How to structure your code:

Each file should contain ONE class, interface, or function. If your file exceeds 200 lines of code, your class, interface or function is probably doing too much.

Do NOT shove multiple classes into a single file. If you do this, I WILL reject your PR, and ask you to split your code across multiple files.

Each file should do exactly ONE thing. If a file is repeatedly modified in several commits, that is usually a sign that it is doing too much.

In general, [follow design patterns](https://refactoring.guru) and the conventions for the language you are writing:

- [typescript style guide](https://google.github.io/styleguide/tsguide.html)
- [go style guide](https://go.dev/doc/effective_go)

If you do NOT follow these style guides, I will reject your PR and show you how to change your code so that it matches.

Organize your code according to import scope. No code should ever import from a parent folder

```
GOOD:

import code from ./path/to/code

BAD:

import code from ../../../code
```

When your code only imports from child folders, it prevents import cycles, and makes it easy for other contributors to reason about the dependencies.

### How to author a commit:
See [`commitlint-config.nix`](.config/commitlint-config.nix)

### How to submit pull requests:

The only way to contribute your code to the main branch is to submit a pull request.

This repository will not let you merge your branch into main if the HEAD of main has diverged from the BASE of your branch.

```
Before pull request:

main     -----0-----1-----2-----3-----4-----5--.
                                                \
                                                 \
your                                              6-----7-----8-----9
branch

After pull request:

main     -----0-----1-----2-----3-----4-----5--.                       .--10
                                                \                     /   ^^^
                                                 \                   /    merge commit
your                                              6-----7-----8-----9
branch

```

Before your submit a pull request, make sure you rebase the main branch onto your branch, and resolve any conflicts.

Once your pull request is approved, you can merge it into the the main branch.

```
Before rebasing
your branch onto
MAIN

another
branch                                            6-----7-----8
                                                 /             \
                                                /               \
main     -----0-----1-----2-----3-----4-----5--:                 '--9 <-- merge commit
                                                \
                                                 \
your                                              6'----7'----8'----9'
branch                                                              ^^^
                                                                    cannot be merged, because HEAD of main is
                                                                    commit 9, and base of your branch is commit 5.
After rebasing
your branch onto main:

another
branch                                            6-----7-----8
                                                 /             \
                                                /               \
main     -----0-----1-----2-----3-----4-----5--:                 '--9 <-- merge commit
                                                                     \
                                                                      \
your                                                                   10----11----12----13
branch                                                                 ^^^
                                                                       can be merged, because HEAD of main is
                                                                       commit 9, and base of your branch is commit 9.


```

You must [sign all commits](https://docs.github.com/en/authentication/managing-commit-signature-verification/signing-commits) in a pull request before you can merge it back into main.

## Test:

- Run `runTest` in the root of this repo to run ALL tests

- Run `runTest` inside a project to run the project's tests.

Every exported function should have a unit test attached to it.

## Document:

<!-- TODO link to "how to write documentation people will actually want to read -->

## Publish:

All projects in this monorepo use [semantic versioning](https://semver.org/) (MAJOR.MINOR.PATCH format) with project-specific prefixes.

To publish a project, run the `publish` command.

The publish command will prompt you to select a major, minor and patch version of your project. Then, it will prompt you to enter a changelog.

By default, the changelog will be a list of all the commit messages on your branch between the previous release, if any, and the current release.

If your language uses a package manifest, e.g. a package.json, pyproject.toml, cargo.toml, the publish command will update it with the current semantic version. Then, it will create a commit with message `chore: bump <project> to v<major>.<minor>.<patch>`, and tag the commit with `<project>/v<major>.<minor>.<patch>.

The publish command does _not_ update any package registry or generate a release.

YOU MUST MERGE YOUR BRANCH TO MAIN to actually publish the project.

Once you merge to main, github actions will automatically create a [release](https://docs.github.com/en/repositories/releasing-projects-on-github/managing-releases-in-a-repository) at the ta. It will also publish your project to its respective package registry.

Github actions will publish
- nix projects to [flakehub](https://flakehub.com/flakes)
- go projects to [pkg.go.dev](https://pkg.go.dev/about#adding-a-package)
- typescript projects to [jsr](https://jsr.io)
